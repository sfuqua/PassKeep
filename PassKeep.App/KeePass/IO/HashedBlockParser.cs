using System;
using System.Collections.Generic;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Security.Cryptography.Core;
using Windows.Storage.Streams;

namespace PassKeep.Lib.KeePass.IO
{
    /// <summary>
    /// 4 bytes: Buffer index (uint32, incrementing)
    /// 32 bytes: Hash
    /// 4 bytes: Buffer size (int32)
    ///     If size is 0, the hash must be 0 (or data is invalid)
    ///         At this point we assert EOS
    /// n bytes: Buffer
    ///     The SHA256 of this block should be equal to the hash we got
    /// </summary>
    internal class HashedBlockParser : IDisposable
    {
        private DataReader reader;

        public HashedBlockParser(IBuffer buffer)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            reader = DataReader.FromBuffer(buffer);
            reader.UnicodeEncoding = Windows.Storage.Streams.UnicodeEncoding.Utf8;
            reader.ByteOrder = ByteOrder.LittleEndian;
        }

        public IBuffer Parse()
        {
            // Skip the first 32 bytes.
            // These are random bytes generated by the writer.
            reader.ReadBuffer(32);

            // Create a reusable hash object.
            var sha256 = HashAlgorithmProvider.OpenAlgorithm(HashAlgorithmNames.Sha256);
            var hash = sha256.CreateHash();

            int currentIndex = 0;
            List<IBuffer> buffers = new List<IBuffer>();
            uint requiredSize = 0;

            // Loop until we're done with the stream.
            while (reader.UnconsumedBufferLength > 0)
            {
                // We require at least 40 bytes per block.
                if (reader.UnconsumedBufferLength < 40)
                {
                    throw new FormatException("The data is incomplete.");
                }

                // Read the current index, current hash, and expected data size.
                UInt32 bufferIndex = reader.ReadUInt32();
                if (bufferIndex != currentIndex++)
                {
                    throw new FormatException(string.Format("The hash check failed. Unexpected buffer index: {0} (should be {1})", bufferIndex, currentIndex - 1));
                }
                IBuffer expectedHash = reader.ReadBuffer(32);
                UInt32 bufferSize = reader.ReadUInt32();

                // If this an empty buffer? We're supposedly done.
                if (bufferSize == 0)
                {
                    for (uint i = 0; i < expectedHash.Length; i++)
                    {
                        if (expectedHash.GetByte(i) != 0)
                        {
                            throw new FormatException("The hash check failed. The final buffer had a nonzero hash.");
                        }
                    }

                    break;
                }

                // Make sure we have enough data to keep reading.
                if (reader.UnconsumedBufferLength < bufferSize)
                {
                    throw new FormatException("The data is incomplete.");
                }

                // Read the next chunk and check its hash.
                IBuffer data = reader.ReadBuffer(bufferSize);
                hash.Append(data);
                IBuffer computedHash = hash.GetValueAndReset();

                for (uint i = 0; i < expectedHash.Length; i++)
                {
                    if (expectedHash.GetByte(i) != computedHash.GetByte(i))
                    {
                        throw new FormatException("The hash check failed. One of the buffers has a bad hash.");
                    }
                }
                buffers.Add(data);
                requiredSize += data.Length;
            }

            // Build a giant buffer from the rest of them.
            uint offset = 0;
            IBuffer finalBuffer = (new byte[requiredSize]).AsBuffer();
            foreach (IBuffer buffer in buffers)
            {
                buffer.CopyTo(0, finalBuffer, offset, buffer.Length);
                offset += buffer.Length;
            }

            return finalBuffer;
        }

        public void Dispose()
        {
            reader.Dispose();
        }
    }
}
