using NativeRijndael;
using PassKeep.Lib.Contracts.KeePass;
using SariphLib.Infrastructure;
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices.WindowsRuntime;
using System.Threading;
using System.Threading.Tasks;
using Windows.Security.Cryptography.Core;
using Windows.Storage.Streams;

namespace PassKeep.Lib.KeePass.SecurityTokens
{
    /// <summary>
    /// Helper class for dealing with key transformation.
    /// </summary>
    public static class KeyHelper
    {
        /// <summary>
        /// The KeePass raw k is 32 bytes generated by the SHA-256 hash of the
        /// concatenation of all user security data.
        /// </summary>
        /// <param name="tokens">The security tokens being used to generate the raw key.</param>
        /// <returns>A 32 byte buffer to use as an encryption k</returns>
        public static async Task<IBuffer> GetRawKey(IEnumerable<ISecurityToken> tokens)
        {
            Dbg.Assert(tokens != null);
            if (tokens == null)
            {
                throw new ArgumentNullException(nameof(tokens));
            }

            var sha256 = HashAlgorithmProvider.OpenAlgorithm(HashAlgorithmNames.Sha256);
            var hash = sha256.CreateHash();

            foreach (ISecurityToken token in tokens)
            {
                hash.Append(await token.GetBuffer());
            }

            IBuffer rawKey = hash.GetValueAndReset();
            return rawKey;
        }

        /// <summary>
        /// The k transformation function takes a raw k (generated by
        /// <see cref="GetRawKey"/>) and encrypts it with ECB Rijndael for
        /// <paramref name="_transformRounds"/> iterations.
        /// 
        /// Since Rijndael works on 16-byte blocks, the k is split in half and
        /// each half is encrypted separately the same number of times.
        /// </summary>
        /// <param name="rawKey">A 32 byte buffer generated from the user's security
        /// preferences</param>
        /// <param name="transformSeed">A 32 byte salt generated by KeePass and collected
        /// from the document metadata</param>
        /// <param name="transformRounds">The number of times to mutate the k</param>
        /// <param name="ct">A <see cref="CancellationToken"/> that allows other threads to request to stop computation</param>
        /// <returns>A mutated k used to encrypt/decrypt the document</returns>
        public static async Task<IBuffer> TransformKey(IBuffer rawKey, IBuffer transformSeed, ulong transformRounds, CancellationToken ct)
        {
            // Split the k buffer in half
            byte[] rawKeyBytes = rawKey.ToArray();
            IBuffer lowerBuffer = WindowsRuntimeBuffer.Create(rawKeyBytes, 0, 16, 16);
            IBuffer upperBuffer = WindowsRuntimeBuffer.Create(rawKeyBytes, 16, 16, 16);

            // Set up the encryption parameters
            var aes = SymmetricKeyAlgorithmProvider.OpenAlgorithm(SymmetricAlgorithmNames.AesEcb);
            var key = aes.CreateSymmetricKey(transformSeed);
            IBuffer iv = null;

            // Run the encryption rounds in two threads (upper and lower)
            ConditionChecker checkForCancel = () => ct.IsCancellationRequested;
            Task<bool> lowerTask = Task.Run(() =>
                {
                    lowerBuffer = KeePassHelper.TransformKey(transformRounds, transformSeed, iv, lowerBuffer, checkForCancel);
                    return !checkForCancel();
                }
            );
            Task<bool> upperTask = Task.Run(() =>
                {
                    upperBuffer = KeePassHelper.TransformKey(transformRounds, transformSeed, iv, upperBuffer, checkForCancel);
                    return !checkForCancel();
                }
            );

            // Verify the work was completed successfully
            await Task.WhenAll(lowerTask, upperTask);
            if (!(lowerTask.Result && upperTask.Result))
            {
                return null;
            }

            // Copy the units of work back into one buffer, hash it, and return.
            IBuffer transformedKey = (new byte[32]).AsBuffer();
            lowerBuffer.CopyTo(0, transformedKey, 0, 16);
            upperBuffer.CopyTo(0, transformedKey, 16, 16);

            var sha256 = HashAlgorithmProvider.OpenAlgorithm(HashAlgorithmNames.Sha256);
            var hash = sha256.CreateHash();
            hash.Append(transformedKey);

            return hash.GetValueAndReset();
        }

        /// <summary>
        /// Computes how many key transformation rounds can occur in one second.
        /// </summary>
        /// <returns>A task representing the computed value.</returns>
        public static Task<ulong> ComputeOneSecondDelay()
        {
            CancellationTokenSource cts = new CancellationTokenSource(TimeSpan.FromSeconds(1));
            return ComputeTransformationRounds(cts.Token);
        }

        /// <summary>
        /// Computes how many key transformation rounds can be completed before cancellation.
        /// </summary>
        /// <param name="ct">Indicates computation is finished.</param>
        /// <returns>A task representing the computated value.</returns>
        private static Task<ulong> ComputeTransformationRounds(CancellationToken ct)
        {
            return Task.Run(() =>
            {
                IBuffer keyBuffer = WindowsRuntimeBuffer.Create(new byte[32], 0, 32, 32);
                IBuffer dataBuffer = WindowsRuntimeBuffer.Create(new byte[32], 0, 32, 32);

                ConditionChecker checkForCancel = () => ct.IsCancellationRequested;
                return KeePassHelper.TransformUntilCancelled(keyBuffer, dataBuffer, checkForCancel);
            });
        }
    }
}
