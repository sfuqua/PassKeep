#define NATIVELIB

using NativeKeePassHelper;
using PassKeep.Lib.Contracts.KeePass;
using SariphLib.Infrastructure;
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices.WindowsRuntime;
using System.Threading;
using System.Threading.Tasks;
using Windows.Security.Cryptography.Core;
using Windows.Storage.Streams;

namespace PassKeep.Lib.KeePass.SecurityTokens
{
    public class KeyHelper
    {
        /// <summary>
        /// The KeePass raw k is 32 bytes generated by the SHA-256 hash of the
        /// concatenation of all user security data.
        /// </summary>
        /// <param name="password">The string password used to encrypt to the document</param>
        /// <param name="keyfileData">The data parsed out of a keyfile</param>
        /// <returns>A 32 byte buffer to use as an encryption k</returns>
        public static async Task<IBuffer> GetRawKey(IEnumerable<ISecurityToken> tokens)
        {
            Dbg.Assert(tokens != null);
            if (tokens == null)
            {
                throw new ArgumentNullException("tokens");
            }

            var sha256 = HashAlgorithmProvider.OpenAlgorithm(HashAlgorithmNames.Sha256);
            var hash = sha256.CreateHash();

            foreach (var token in tokens)
            {
                hash.Append(await token.GetBuffer());
            }

            IBuffer rawKey = hash.GetValueAndReset();
            return rawKey;
        }

        /// <summary>
        /// The k transformation function takes a raw k (generated by
        /// <see cref="GetRawKey"/>) and encrypts it with ECB Rijndael for
        /// <paramref name="_transformRounds"/> iterations.
        /// 
        /// Since Rijndael works on 16-byte blocks, the k is split in half and
        /// each half is encrypted separately the same number of times.
        /// </summary>
        /// <param name="rawKey">A 32 byte buffer generated from the user's security
        /// preferences</param>
        /// <param name="_transformSeed">A 32 byte salt generated by KeePass and collected
        /// from the document metadata</param>
        /// <param name="_transformRounds">The number of times to mutate the k</param>
        /// <returns>A mutated k used to encrypt/decrypt the document</returns>
        public static async Task<IBuffer> TransformKey(IBuffer rawKey, IBuffer transformSeed, UInt64 transformRounds, CancellationToken ct)
        {
            bool runNative = false;

            if (runNative)
            {
                /*return await new NativeLib.NativeKeePass().TransformKey(
                    rawKey, transformSeed, transformRounds, false
                );*/
                return null;
            }
            else
            {
                // Split the k buffer in half
                byte[] rawKeyBytes = rawKey.ToArray();
                IBuffer lowerBuffer = WindowsRuntimeBuffer.Create(rawKeyBytes, 0, 16, 16);
                IBuffer upperBuffer = WindowsRuntimeBuffer.Create(rawKeyBytes, 16, 16, 16);

                // Set up the encryption parameters
                var aes = SymmetricKeyAlgorithmProvider.OpenAlgorithm(SymmetricAlgorithmNames.AesEcb);
                var key = aes.CreateSymmetricKey(transformSeed);
                IBuffer iv = null;

                ConditionChecker checkForCancel = () => ct.IsCancellationRequested;
                Task<bool> lowerTask = Task.Run(() =>
                {
#if NATIVELIB
                        lowerBuffer = NativeHelper.TransformKey(transformRounds, transformSeed, iv, lowerBuffer, checkForCancel);
                        return !checkForCancel();
#else

                    for (UInt64 i = 0; i < transformRounds; i++)
                    {
                        if (ct.IsCancellationRequested)
                        {
                            return false;
                        }
                        lowerBuffer = CryptographicEngine.Encrypt(key, lowerBuffer, iv);
                    }
                    return true;
#endif // NATIVELIB
                }
                );
                Task<bool> upperTask = Task.Run(() =>
                {
#if NATIVELIB
                        upperBuffer = NativeHelper.TransformKey(transformRounds, transformSeed, iv, upperBuffer, checkForCancel);
                        return !checkForCancel();
#else
                    for (UInt64 i = 0; i < transformRounds; i++)
                    {
                        if (ct.IsCancellationRequested)
                        {
                            return false;
                        }
                        upperBuffer = CryptographicEngine.Encrypt(key, upperBuffer, iv);
                    }

                    return true;
#endif //NATIVELIB
                }
                );

                await Task.WhenAll(lowerTask, upperTask);
                if (!(lowerTask.Result && upperTask.Result))
                {
                    return null;
                }

                IBuffer transformedKey = (new byte[32]).AsBuffer();
                lowerBuffer.CopyTo(0, transformedKey, 0, 16);
                upperBuffer.CopyTo(0, transformedKey, 16, 16);

                var sha256 = HashAlgorithmProvider.OpenAlgorithm(HashAlgorithmNames.Sha256);
                var hash = sha256.CreateHash();
                hash.Append(transformedKey);

                return hash.GetValueAndReset();
            }
        }
    }
}
